# 目录

- [1.实现快速排序代码](#1.实现快速排序代码)
- [2.实现Self_Attention](#2.实现Self_Attention)
- [3.最大子数组和](#3.最大子数组和)
- [4. k个一组翻转链表](#4. k个一组翻转链表)
- [5.子树的最大平均值](#5.子树的最大平均值)
- [6.无序数组的第k大的数](#6.无序数组的第k大的数)
- [7.最长递增子序列](#7.最长递增子序列)
- [8.时针与分针的夹角](#8. 时针与分针的夹角)
- [9. 无重复子串的最大长度](#9. 无重复子串的最大长度)
- [10. 跳跃游戏](10. 跳跃游戏)
- [11. 复原IP地址](#11. 复原IP地址)
- [12. 搜索旋转排序数组](#12. 搜索旋转排序数组)
- [13. 岛屿数量](#13. 岛屿数量)
- [14. 二叉树的最近公共祖先](#14. 二叉树的最近公共祖先)
- [15. 两数之和](#15. 两数之和)
- [16. 链表部分反转](#16. 链表部分反转)
- [17. 合并有序链表](#17. 合并有序链表)
- [18. N个字符串组成新字符串](#18. N个字符串组成新字符串)
- [19. 乘积和异或相等的子序列](#19. 乘积和异或相等的子序列)
- [20. 并查集](#20. 并查集)
- [21. 分割回文子串](#21. 分割回文子串)
- [22. 连续k个子数组的最大和](#22. 连续k个子数组的最大和)
- [23. 可被三除的最大和](#23. 可被三除的最大和)
- [24. 排序链表](#24. 排序链表)
- [25. 最大子数组](#25. 最大子数组)
- [26. ip地址转数字](#26. ip地址转数字)
- [27. 有序链表插入一个节点保持有序](#27. 有序链表插入一个节点保持有序)
- [28. 全排列](#28. 全排列)
- [29. 全排列II](#29. 全排列II)
- [30. 子集II](#30. 子集II)
- [31. 从中序与后序遍历序列构造二叉树](#31. 从中序与后序遍历序列构造二叉树)
- [32. 四数之和](#32. 四数之和)
- [33. 分割等和子集](#33. 分割等和子集)
- [34. 完全背包理论基础](#34. 完全背包理论基础)
- [35. 买卖股票的最佳时机](#35. 买卖股票的最佳时机)
- [36. 买卖股票的最佳时机III](#36. 买卖股票的最佳时机III)
- [37. 打家劫舍](#37. 打家劫舍)
- [38.编辑距离](#38.编辑距离)


<h2 id="1.实现快速排序代码">1.实现快速排序代码</h2>
⭐⭐⭐

```C++
class Solution {
public:
    int partition(vector<int>& nums, int left, int right) {
        int i = rand() % (right - left + 1) + left;
        int pivot = nums[i];
        swap(nums[i], nums[right]);
        i = left - 1;
        for (int j=left; j<right; j++) {
            if (nums[j] < pivot) {
                i++;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i+1], nums[right]);
        return i+1;
    }

    void quickSort(vector<int>& nums, int left, int right) {
        if (left < right) {
            int pos = partition(nums, left, right);
            quickSort(nums, left, pos-1);
            quickSort(nums, pos+1, right);
        }
    }

    vector<int> sortArray(vector<int>& nums) {
        quickSort(nums, 0, nums.size()-1);
        return nums;
    }
};
```



### 时间复杂度
- **最佳和平均情况**：对于平均分布的数据，快速排序的时间复杂度通常是 $O(n \log n)$。这是因为每次分区大约将数组分成两半，需要递归或迭代地应用这一过程大约 $\log n$ 次。
- **最坏情况**：在最坏的情况下，如果每次选择的基准都是最小或最大的元素，快速排序的时间复杂度会退化到 $O(n^2)$。这种情况在数组已经基本有序的情况下可能发生（完全正序或完全逆序），每次分区操作只能减少一个元素。

### 空间复杂度
- **递归版本**：递归版本的快速排序在最坏情况下的空间复杂度可以达到 $O(n)$，这是由递归调用栈深度决定的。在平均情况下，由于递归的深度接近 $\log n$，其空间复杂度是 $O(\log n)$。
- **迭代版本**：迭代版本使用一个显式的栈来存储未处理的子数组的界限。虽然这避免了函数调用的开销，但栈的空间使用仍然可以在最坏情况下达到 $O(n)$，特别是当数组几乎有序时，可能需要将许多小的子数组范围推入栈。在平均情况下，空间复杂度通常也是 $O(\log n)$，因为每次都将数组大致分成两部分。

### 稳定性
- **不稳定排序**：相等的元素可能由于分区而交换其原始顺序。

### 实用性和选择
尽管迭代版本避免了递归的潜在栈溢出问题，它在空间和时间上的复杂度与递归版本相似。选择递归还是迭代版本通常取决于具体的应用场景以及对栈溢出的考虑。迭代版本更适合于那些对栈空间使用有严格限制的环境，例如嵌入式系统或者非常大的数据集处理。

在实际应用中，可以通过随机选择基准值或使用“三数取中”法来选择基准值，以避免最坏情况的发生，从而使得快速排序的性能更加稳定。此外，对于小数组，可以切换到插入排序以提高效率，因为小数组上的插入排序可能比快速排序更快。这种组合策略在实际库中如C++的STL中被广泛应用。

<h2 id="2.实现Self_Attention（百度实习一面）">2.实现Self_Attention</h2>

⭐⭐⭐

    import torch
    import torch.nn as nn
    
    class Attention(nn.Module):
        def __init__(self, embed_dim, num_heads, dropout=0.1):
            super(Attention, self).__init__()
            self.embed_dim = embed_dim
            self.num_heads = num_heads
            assert embed_dim % num_heads == 0, "embed_dim must be divisible by num_heads"
            self.head_dim = embed_dim // num_heads
    
            self.QW = nn.Linear(embed_dim, embed_dim)
            self.KW = nn.Linear(embed_dim, embed_dim)
            self.VW = nn.Linear(embed_dim, embed_dim)
            self.output_weights = nn.Linear(embed_dim, embed_dim)
            self.dropout = nn.Dropout(dropout)
    
        def split_heads(self, x):
            B, N, D = x.shape
            x = x.reshape(B, N, self.num_heads, self.head_dim).transpose(1, 2)
            return x
    
        def forward(self, query, key, value, mask=None):
            B, N, D = query.shape
            query = self.QW(query)
            key = self.KW(key)
            value = self.VW(value)
            query = self.split_heads(query)
            key = self.split_heads(key)
            value = self.split_heads(value)
    
            attn = torch.matmul(query, key.transpose(-2, -1))
            attn = attn / (self.head_dim ** 0.5)
            if mask is not None:
                attn = attn.masked_fill(mask == 0, float('-inf'))
    
            attn = torch.softmax(attn, dim=-1)
            attn = self.dropout(attn)
    
            output = torch.matmul(attn, value)
    
            output = output.transpose(1, 2).reshape(B, N, D)
            return output



<h2 id="3.最大子数组和">3.最大子数组和</h2>

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

```C++
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        vector<int> dp(nums.size(), INT_MIN); // dp[i]表示以nums[i]结尾的组数组的最大和
        int ans = nums[0];
        dp[0] = nums[0];
        for (int i=1; i<nums.size(); i++) {
            dp[i] = max(dp[i-1] + nums[i], nums[i]);
            ans = max(dp[i], ans);
        }
        return ans;
    }
};
```





## 4. k个一组翻转链表

```C++
class Solution {
public:
    pair<ListNode*, ListNode*> reserse(ListNode* head) {
        ListNode* tail = head;
        ListNode* pre = nullptr;
        while(head!=nullptr) {
            ListNode* next = head->next;
            head->next = pre;
            pre = head;
            head = next;
        }
        return {pre, tail};
    }

    ListNode* reverseKGroup(ListNode* head, int k) {
        ListNode* dummpyHead = new ListNode(0, head);
        ListNode* cur = dummpyHead;
        while(true) {
            // 判断是否有个k节点
            ListNode* node = cur;
            for (int i=0; i<k; i++) {
                node = node->next;
                if (node==nullptr) {
                    return dummpyHead->next;
                }
            }
            ListNode* tmp = node->next;
            node->next = nullptr;
            pair<ListNode*, ListNode*> p = reserse(head);
            cur->next = p.first;
            p.second->next = tmp;
            head = tmp;
            cur = p.second;
        }
        return dummpyHead->next;
    }
};
```



## 5.子树的最大平均值

⭐⭐⭐

给你一棵二叉树的根节点 `root`，找出这棵树的 **每一棵** 子树的 **平均值** 中的 **最大** 值。

```C++
class Solution {
public:
    double ans = 0;
    pair<int, int> dfs(TreeNode* root) {
        if (root==nullptr) {
            return {0, 0};
        }
        auto [ls, ln] = dfs(root->left); // 左子树的节点以及节点个数
        auto [rs, rn] = dfs(root->right);// 右子树的节点以及节点个数
        int s = root->val + ls + rs;
        int n = 1 + ln + rn;
        ans = max(ans, s * 1.0 / n);
        return {s, n};
    }
    double maximumAverageSubtree(TreeNode* root) {
        dfs(root);
        return ans;
    }
};
```





## 6.无序数组的第k大的数

⭐⭐⭐

```C++
class Solution {
public:
    int partition(vector<int>& nums, int l, int r) {
        int i = rand() % (r - l + 1) + l;
        int pivot = nums[i];
        swap(nums[i], nums[r]);
        i = l - 1;
        for (int j=l; j<r; j++) {
            if (nums[j] > pivot) {
                i++;
                swap(nums[i], nums[j]);
            }
        }
        swap(nums[i+1], nums[r]);
        return i+1;
    }

    void quickSort(vector<int>& nums, int l, int r) {
        if (l < r) {
            int pos = partition(nums, l, r);
            quickSort(nums, l, pos-1);
            quickSort(nums, pos+1, r);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        quickSort(nums, 0, nums.size()-1);
        return nums[k-1];
    }
};
```





## 7.最长递增子序列

最长递增子序列（Longest Increasing Subsequence，简称 LIS）是在一个序列中寻找一个最长的子序列，使得这个子序列中的元素是递增的

```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int n = nums.size();
        vector<int> dp(n, 1); // dp[i]表示以nums[i]为结尾的子序列的最大长度
        int ans = 1;
        for (int i=1; i<n; i++) {
            for (int j=0; j<i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = max(dp[i], dp[j]+1);
                }
            }
            ans = max(ans, dp[i]);
        }
        return ans;
    }
};
```



## 8. 时针与分针的夹角

```C++
#include <iostream>
#include <cmath>

double calculateAngle(int hour, int minute) {
    double hour_angle = (hour % 12) * 30 + minute * 0.5;
    double minute_angle = minute * 6;
    double angle_diff = std::abs(hour_angle - minute_angle);
    double final_angle = std::min(angle_diff, 360 - angle_diff);
    return final_angle;
}

int main() {
    int hour, minute;
    std::cout << "Enter the hour: ";
    std::cin >> hour;
    std::cout << "Enter the minute: ";
    std::cin >> minute;

    double angle = calculateAngle(hour, minute);
    std::cout << "The angle between the hour and minute hands is: " << angle << " degrees." << std::endl;

    return 0;
}
```



## 9. 无重复子串的最大长度

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长连续子字符串** 的长度。

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if (s.size() <= 0) {
            return 0;
        }
        unordered_map<char, int> umap;
        int maxLength = 0;
        int l = 0, r = 0;
        int n = s.size();
        while(r < n) {
            if (umap.find(s[r])==umap.end() || umap[s[r]]==0) {
                umap[s[r]]++;
                r++;
            }
            else {
                umap[s[l++]]--;
            }
            maxLength = max(maxLength, r - l);
        }
        return maxLength;
    }
};
```



## 10. 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

```C++
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int n = nums.size();
        int maxLenght = 0;
        for (int i=0; i<n; i++) {
            if (maxLenght < i) {
                return false;
            }
            maxLenght = max(maxLenght, i + nums[i]);
        }
        return true;
    }
};
```

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。返回到达 `nums[n - 1]` 的最小跳跃次数。

```C++
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1) return 0;
        int ans = 0; // 一共要多少步
        int curDistance = 0; // 当前的最远距离
        int nextDistance = 0; // 下一步的最远距离
        for (int i=0; i<nums.size()-1; i++) {
            nextDistance = max(nextDistance, i+nums[i]);
            if (i==curDistance) {
                ans += 1;
                curDistance = nextDistance;
                if (nextDistance>=nums.size()-1) break;
            }
        }
        return ans;
    }
};
```



## 11. 复原IP地址

⭐⭐⭐

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

```C++
class Solution {
private:
    string res;
    int count = 0;
    vector<string> ans;
public:
    bool isValidate(const string& s) {
        int num = stoi(s); // 将表示整数的字符串转换为 int 类型的整数。
        if (num > 255) return false;
        if (s.size() > 1 && s[0] == '0') return false;
        return true;
    }
    void dfs(int startIdx, const string& s) {
        if (startIdx >= s.size() || count >= 4) return;
        for (int i=startIdx; i<s.size() && (i-startIdx) < 3; i++) {
            string substring = s.substr(startIdx, i-startIdx+1);
            if (isValidate(substring)) {
                substring += ".";
                res += substring;
                count++;
            }
            else break;
            if (i==s.size()-1 && count==4) {
                ans.push_back(res.substr(0, res.size()-1));
            }
            dfs(i+1, s);
            res = res.substr(0, res.size()-substring.size());
            count--;
        }
    }
    vector<string> restoreIpAddresses(string s) {
        dfs(0, s);
        return ans;
    }
};
```



## 12. 搜索旋转排序数组

⭐⭐⭐

```C++
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size()-1;
        int n = nums.size()-1;
        while(l <= r) {
            int mid = (l + r) / 2;
            if (nums[mid] == target) return mid;
            if (nums[0] <= nums[mid]) {
                if (nums[0] <= target && target < nums[mid]) {
                    r = mid - 1;
                }
                else {
                    l = mid + 1;
                }
            }
            else {
                if (target <= nums[n] && nums[mid] < target) {
                    l = mid + 1;
                }
                else {
                    r = mid - 1;
                }
            }
        }
        return -1;
    }
};
```



## 13. 岛屿数量

```C++
class Solution {
public:
    int m, n;
    int directions[4][2] = {1, 0, -1, 0, 0, 1, 0, -1};
    void bfs(const vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
        if (grid[x][y] == '0' || visited[x][y]) {
            return;
        }
        visited[x][y] = true;
        for (int i=0; i<4; i++) {
            int nextx = x + directions[i][0];
            int nexty = y + directions[i][1];
            if (nextx < 0 || nexty < 0 || nextx >= m || nexty >= n) {
                continue;
            }
            bfs(grid, visited, nextx, nexty);
        }
    }
    int numIslands(vector<vector<char>>& grid) {
        int ans = 0;
        m = grid.size();
        n = grid[0].size();
        vector<vector<bool>> visited(m, vector<bool> (n, false));
        for (int i=0; i<m; i++) {
            for (int j=0; j<n; j++) {
                if (grid[i][j] == '1' && !visited[i][j]) {
                    ans++;
                    bfs(grid, visited, i, j);
                }
            }
        }
        return ans;
    }
};
```



## 14. 二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

⭐⭐⭐

```C++
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr || root == p || root == q) return root;
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
        if (left == nullptr) return right;
        if (right == nullptr) return left;
        return root;
    }
};
```



## 15. 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。数组中同一个元素在答案里不能重复出现。

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        int n = nums.size();
        unordered_map<int, int> umap;
        for (int i=0; i < n; i++) {
            umap[nums[i]] = i;
        }
        for (int i=0; i<n; i++) {
            if (umap.find(target-nums[i])!=umap.end() && i != umap[target-nums[i]]) {
                return {i, umap[target-nums[i]]};
            }
        }
        return {};
    }
};
```



## 16. 链表部分反转

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

```C++
class Solution {
public:
    pair<ListNode*, ListNode*> reverser(ListNode* node) {
        ListNode* pre = nullptr;
        ListNode* tail = node;
        while(node!=nullptr) {
            ListNode* tmp = node->next;
            node->next = pre;
            pre = node;
            node = tmp;
        }
        return {pre, tail};
    }
    ListNode* reverseBetween(ListNode* head, int left, int right) {
        ListNode* dummpyHead = new ListNode(0, head);
        ListNode* leftNode = dummpyHead;
        for (int i=0; i<left-1; i++) {
            leftNode = leftNode->next;
        }
        cout << leftNode->val << endl;
        ListNode* rightNode = leftNode;
        for (int i=0; i<=(right-left); i++) {
            rightNode = rightNode->next;
        }

        // 反转
        ListNode* tmp = rightNode->next;
        rightNode->next = nullptr;
        pair<ListNode*, ListNode*> p = reverser(leftNode->next);
        leftNode->next = p.first;
        p.second->next = tmp;
        return dummpyHead->next;
    }
};
```



## 17. 合并有序链表



## 18. N个字符串组成新字符串



## 19. 乘积和异或相等的子序列



## 20. 并查集



## 21. 分割回文子串



## 22. 连续k个子数组的最大和



## 23. 可被三除的最大和



## 24. 排序链表



## 25. 最大子数组



## 26. ip地址转数字



## 27. 有序链表插入一个节点保持有序



## 28. 全排列



## 29. 全排列II



## 30. 子集II



## 31. 从中序与后序遍历序列构造二叉树



## 32. 四数之和



## 33. 分割等和子集



## 34. 完全背包理论基础



## 35. 买卖股票的最佳时机



## 36. 买卖股票的最佳时机III



## 37. 打家劫舍



## 38.编辑距离

